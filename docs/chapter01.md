# 1장. 계층형 아키텍처의 문제는 무엇일까?

> 계층을 잘 구성하면 각 계층 사이에 영향을 주지 않고 독립적으로 도메인 로직을 작성할 수 있다.  

<img width="400" alt="image" src="https://user-images.githubusercontent.com/42997924/167240908-54b4049a-456b-4288-b2c3-7505ef3447b5.png">

**각 계층의 역할**

1. `웹 레이어`
   - 요청을 받아 적절한 비즈니스 로직으로 라우팅
   - 흔히 말하는 **MVC**가 포함된 계층
2. `도메인 레이어`
   - 서비스/시스템의 **(핵심 로직)**
   - 유효성 검사 및 계산하는 Business 논리 계층
   - 도메인 엔티티의 상태를 조회, 변경하기 위해 영속성 계층의 컴포넌트 호출
3. `영속성 레이어`
   - DAO 계층
   - Database / Message Queue / 외부 API 와의 통신 등 처리
   - 영구 데이터를 관리하는 방법을 분류하는 데이터 접근 계층

> "도메인 객체와 영속성 계층을 어디까지 분리할 것인가"에 대한 고민은 [이동욱님이 작성하신 글](https://jojoldu.tistory.com/603) 을 참고하면 좋을 것 같다. 대부분은 그렇듯, 은총알은 없다.

중요한 건, 각 계층(Layer)은 잘 구현하면 현재 구현된 기능에 영향을 주는 것 없이 새로운 기능을 구현할 수 있다.(OCP 원칙)

단, 잘못하면 계층형 아키텍처는 잘못된 습관이 스며들 수 있도록 하는 많은 측면들이 존재하며 시간이 지날수록 애플리케이션의 변경(유지보수)을 어렵게 만든다.

## 1-1. 데이터베이스 주도 설계를 유도

일반적인 애플리케이션의 목적을 생각해보자.

비즈니스(유스케이스)를 위한 규칙, 정책을 반영한 모델을 통해 사용자 편리한 활용이 목적이다.

#### 유스케이스 구현 프로세스

1. 데이터베이스의 구조 고민
2. 이를 바탕으로 도메인 로직(핵심 로직) 구현

전통적인 계층형 아키텍처에서는 합리적인 방법이다. 왜냐하면, 의존성 방향에 따라 자연스럽게 구현하는 것이기 때문이다.

**비즈니스 관점**에서 다시 생각해보자.

1. 도메인(비즈니스) 로직을 먼저 고민
2. 이를 바탕으로 영속성 계층(DB 등)과 웹 계층 구현

데이터베이스 중심적인 설계를 불러오는 가장 큰 원인은 ORM 프레임워크를 사용하는 것이다.

> 계층형 아키텍처와 ORM이 결합하면 비즈니스 규칙을 영속성 관점과 섞기 쉽다.

<img width="400" alt="image" src="https://user-images.githubusercontent.com/42997924/167242377-ac11e5e8-62e0-4584-9c32-af88fca0fde3.png">

- ORM에 의해 관리되는 엔티티들은 보통 영속성 계층에 둔다
- 계층은 아래 방향으로 접근 가능하기 때문에 도메인 → 엔티티 접근 가능 
- 접근하면 도메인 계층과 영속성 계층 사이에 강한 결합 발생

> 도메인 로직을 구현하면서 즉시로딩/지연로딩 문제, 트랜잭션 관리, 캐시 초기화 등의 영속성 계층과 관련된 작업을 해야만 한다.

## 1-2. 지름길 선택 가능(레이어 바꾸기)

> 전통적인 계층형 아키텍처에서 전체적으로 적용되는 유일한 규칙은 특정한 계층에서는 같은 계층에 있는 컴포넌트나 아래에 있는 계층에만 접근 가능하다는 것

### 지름길의 의미

- 상위 계층에 접근을 해야 하는 컴포넌트(또는 클래스)가 있다면 단순히 하위 계층으로 내리는 것

특정 계층에 속하지 않는 것 처럼 보이는 헬퍼 컴포넌트, 유틸 클래스 등을 하위 계층으로 내리기 쉽다.

<img width="400" alt="image" src="https://user-images.githubusercontent.com/42997924/167242796-091e0a03-237c-49da-8518-dbf4d2747635.png">

따라서 위와 같이 Persistence 레이어에 모든것이 몰려있는 기이한 현상이 나타날 수 있다.

> 이를 방지하고 싶다면, 적어도 추가적인 아키텍처 규칙을 강제해야한다.  
> 그럴 수 없다면, 현재 프로젝트에 계층형 아키텍처는 최선이 아닐 수 있다.

## 1-3. 테스트하기 어려워진다

> 계층형 아키텍처는 테스트에 도움이 될까?

계층형 아키텍처는 계층을 건너뛸 수도 있다.

<img width="400" alt="image" src="https://user-images.githubusercontent.com/42997924/167243023-e47475f2-1471-4613-8c2b-994f8a1deb28.png">

웹 요청 처리가 엔티티의 필드를 단 하나만 조작하는 경우 위와 같은 구조가 나올 수 있다. (당연히 좋지 않은 구조이다)

**문제점**

1. 도메인 로직을 웹 계층에서 구현하는 문제
   - 만약 유즈케이스가 확장되면 책임이 섞이고 핵심 도메인 로직이 분산
2. 웹 계층 테스트 시 도메인 계층뿐 아니라 영속성 계층도 모킹해야 함
   - 단위 테스트 복잡도 떡상

> 규모가 커질수록 의존성은 쌓이고, 테스트 작성 시 의존성을 이해하고 mock 데이터를 만드는데 더 많은 시간을 소요

## 1-4. 유스케이스를 숨긴다

> 계층형 아키텍처는 기능 추가/변경 시, 올바른 위치를 빠르게 찾을 수 있을까?

**문제점**

1. 도메인 로직 분산
   - 앞서 언급한 것처럼 도메인 로직이 여러 레이어에 걸쳐서 쉽게 흩어질 수 있기 때문에, 변경할 코드의 올바른 위치를 찾는 것을 어렵게 만든다. 
2. 서비스 크기에 제한 없음 (넓은 서비스)
   - 도메인 서비스의 크기에 대해서 어떠한 룰로 강제를 하지 않음
   - 넓은 서비스는 영속성 계층에 많은 의존성을 갖게 됨

**넓은 서비스 → 많은 의존성 → 테스트 어려움 → 작업할 유스케이스 찾기 어려움**

> 해결 방법은, 고도로 특화된 좁은 도메인 서비스가 유스케이스 하나씩만 담당하게 하면 된다.

## 1-5. 동시 작업이 어려워진다

> 계층형 아키텍처는 개발 협업에 유리할까?

모든 것이 영속성 계층 위에 만들어지기 때문에 영속성 계층을 먼저 개발하고 도메인 계층 마지막으로 웹 계층을 만들어야 한다.

코드에 넓은 서비스가 있다면 서로 다른 기능을 동시에 작업하기가 더욱 어렵다. 같은 파일을 작업하기 때문에 `merge conflict`와 같은 문제가 생길 확률이 높다.

## 1-6. 정리

계층형 아키텍처는 위와 같이 많은 것들이 잘못된 방향으로 흘러가기 쉽다.

만약 엄격한 룰을 강제하고, 품질에 신경쓴다면 계층형 아키텍처는 유지보수하기 좋은 아키텍처가 될 수 있다.

### 우리 계층형은 말이에요

- 유지보수에 분리한 잘못된 방식을 허용하니, 개발 조직이 잘 이해하고 사용하도록 노력해야한다.
