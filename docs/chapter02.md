# 2장. 의존성 역전하기

> 아픈 손가락인 계층형 아키텍처의 대안은 있을까  
> 유지보수에 중요한 `SRP`와 `DIP`관점에서 살펴보자

## 2-1. 단일 책임 원칙(SRP)

이 원칙의 일반적인 해석은 다음과 같다.

> 하나의 컴포넌트는 오로지 한 가지 일만 해야하고, 그것을 올바르게 수행해야 한다.

이는 오해의 여지가 있다. 정확히 표현하면 다음과 같다.

> ⭐️ 컴포넌트를 변경하는 이유는 오직 하나뿐이어야 한다.

`SRP`의 `책임(R)`은 ~~한 가지 일만 하는 것~~ 이 아니라 **변경할 이유**로 해석한다는 의미이다.(충격)

### `SRP`가 잘 지켜지면?

- 만약 컴포넌트를 변경할 이유가 한 가지가 지켜졌다.
- **어떤 다른 이유로** 소프트웨어를 변경하더라도 이 컴포넌트에 대해서는 전혀 신경 쓸 필요가 없다. 
- 소프트웨어가 변경되더라도 여전히 우리가 기대한 대로 동작한다.

> 유지보수 효율 떡상

### 변경할 이유가 많은 케이스

<img width="400" alt="image" src="https://user-images.githubusercontent.com/42997924/167244357-4144903a-d217-46a4-b837-f5e6f85328d8.png">

안타깝게도 변경할 이유라는 것은 컴포넌트 간의 의존성을 통해 너무도 쉽게 전파된다. 

> 어떤 컴포넌트의 의존성(전의 의존성 포함) 각각은 이 컴포넌트를 변경하는 이유 하나씩에 해당한다.

컴포넌트 A는 여러 컴포넌트에 의존하는 반면 E는 의존하는 것이 없다.

컴포넌트 E를 변경할 유일한 이유는 새로운 요구사항에 의해 E의 기능을 바꿔야 할 때 뿐이다. A의 경우 어떤 컴포넌트가 바뀌든 같이 바뀌어야 한다.

> SRP를 위반하면 규모가 커질수록 변경이 더욱 어려워지고 비용도 증가한다.  
> 유지보수 효율이 떡락한다는 의미다

## 2-2. 부수효과(사이드 이펙트)

- SRP가 지켜지지 않은 코드에서 핵심 컴포넌트의 변경은 사이드 이펙트가 발생할 가능성이 큼
- 핵심 컴포넌트 변경하면 쉬운 비즈니스를 어렵게 풀어가야하는 상황이 발생할 수 있다.
- 유지보수에 유리하도록 SRP를 잘 지키는 것이 중요하다. 

> SRP를 지키지 않는 의존이 많은 컴포넌트의 변경은 위험하다.    
> 의존의 방향 또한 중요한 이유이다.

## 2-3. 의존성 역전 원칙(DIP)

> 의존성에 관련된 문제를 해결하기 위해 어떻게 하면 좋을까?

계층형 아키텍처는 의존성 방향에 따라 상위 계층이 하위 계층에 비해 변경 확률이 높다.

그러므로 영속성 계층을 변경할 때마다 잠재적으로 도메인 계층도 변경해야 한다.

- 도메인 코드는 애플리케이션에서 가장 중요한 코드이다. 
- 영속성 코드가 바뀐다고 해서 도메인 코드까지 바꾸고 싶지는 않을 것이다.

의존성 역전 원칙을 활용하면 된다!

> ⭐️ `DIP(Dependecy Inversion Principle)`  
> 코드상의 어떤 의존성이든 그 방향을 바꿀 수(역전시킬 수) 있다.

<details><summary>예외도 존재한다</summary>
사실 의존성의 양쪽 코드를 모두 제어할 수 있을 때만 의존성을 역전시킬 수 있다. 만약 서드파티 라이브러리에 의존성이 있다면 해당 라이브러리를 제어할 수 없기 때문에 이 의존성을 역전시킬 수 없다.
</details> 

DIP 적용을 위해 1장에서 다뤘던 구조에서 변경해보자.

<img width="400" alt="image" src="https://user-images.githubusercontent.com/42997924/167245167-a8d48306-3b5a-4ee3-8d10-b6d15a2136d2.png">

1. 엔티티를 도메인 계층으로 옮긴다
   - ⭐️ 순환 의존성 발생(영속성 계층의 Repository가 Entity에 의존하기 때문)
2. 도메인 계층에 `Repository 인터페이스`를 만들고 `Repository 구현체`를 영속성 계층에 만든다(`DIP`) 

<img width="400" alt="image" src="https://user-images.githubusercontent.com/42997924/167245313-3190e466-9cb3-423b-98a7-27890651c10a.png">

> 도메인 계층에 인터페이스를 도입함으로써 의존성을 역전시킬 수 있고, 그 덕분에 영속성 계층이 도메인 계층에 의존하게 된다.

## 2-4. 클린 아키텍처

로버트 C. 마틴의 "클린 아키텍처" 책의 정의에 의하면

- 설계가 비즈니스 규칙의 테스트를 용이하게 함
- 비즈니스 규칙은 프레임워크, 데이터베이스, UI 기술, 그 밖의 외부 애플리케이션이나 인터페이스로부터 독립적일 수 있음

> 이는 도메인 코드가 밖으로 향하는 어떤 의존성도 없어야 함을 의미  
> 대신 의존성 역전 원칙의 도움으로 모든 의존성이 도메인 코드를 향함

<img width="450" alt="image" src="https://user-images.githubusercontent.com/42997924/167384757-8fc3c81b-141c-430a-ab62-50b2fc765fff.png">

(⬆️ 출처 : [클린 아키텍처](https://shorturl.ae/V4Mm2))

#### 의존성 규칙

> 클린 아키텍처에서 모든 의존성은 도메인 로직을 향해 안쪽 방향으로 향해야 함

- `코어` = 도메인 계층 + 애플리케이션 계층
- `유스케이스` = 서비스를 세분화 (단일 책임을 갖기 위해)
   - 넓은 서비스 문제를 피할 수 있음
   
   
도메인 코드에서는 어떤 영속성 프레임워크나 UI 프레임워크가 사용되는지 알 수 없기 때문에 특정 프레임워크에 특화된 코드를 가질 수 없고 비즈니스 규칙에 집중할 수 있다. 그래서 도메인 코드를 자유롭게 모델링 할 수 있다.

### Entity의 모델을 각 계층에서 유지보수 해야 함

- 클린 아키텍처에 코드 복잡성이 증가할 수 있는 요인
- 도메인이 철저하게 분리되므로 각 계층에서 Entity 모델을 유지보수 함

> JPA 예시  
> DB-객체 매핑 메타데이터 Entity 클래스를 영속성 계층과 도메인 계층에서 각각 만들어야 함

조금 복잡해 보일 수 있지만, 결합이 제거된 상태이기 때문에 **바람직한 일** 이다. (8장에서 '매핑하지 않기 전략' 등을 알아본다)

다소 추상적인 클린 아키텍처를 구체화한 헥사고날 아키텍처에 대해 알아보자.

## 2-5. 육각형 아키텍처(헥사고날 아키텍처)

'육각형 아키텍처'라는 용어는 알리스테어 콕번이 만든 용어다.

![image](https://user-images.githubusercontent.com/42997924/167653953-b86408cf-7f0d-45ad-987b-29f54659a996.png)

⬆️ 출처 : [Get Your Hands Dirty on Clean Architecture](https://subscription.packtpub.com/book/web_development/9781839211966/2/ch02lvl1sec11/hexagonal-architecture)

- 애플리케이션 코어가 육각형(모양과 육각형은 사실 의미가 없다고 한다)
- 육각형(코어)에서 외부로 향하는 의존성이 없음(모든 의존성은 코어를 향함)
- 외부에 애플리케이션과 상호작용하는 어댑터들 존재

![image](https://user-images.githubusercontent.com/42997924/167653544-008d7cd9-ce5e-4a53-80d4-65defed0a22d.png)

### 포트와 어댑터

코어와 상호작용하는 `어댑터`가 존재하고, 코어-어댑터를 통신하도록 해주는 `포트`가 제공된다.

⬆️ 출처 : [마이크로 서비스 패턴](http://www.yes24.com/Product/Goods/86542732)

다른 서적에 있는 좋은 예시가 있어서 들고왔다.

- `왼쪽에 있는 어댑터` : 주도하는 어댑터(Driving Adapter)
  - 애플리케이션 코어를 호출하기 때문에
- `오른쪽에 있는 어댑터` : 주도되는 어댑터(Driven Adapter)
  - 애플리케이션 코어에 의해 호출되기 때문에

> 코어-어댑터가 통신하기위한 포트는 코어가 제공

- 주도하는 어댑터의 포트
  - 유스케이스 클래스에서 구현 - 호출되는 인터페이스 존재
- 주도되는 어댑터의 포트
  - 어댑터에의해 구현 - 코어에 의해 호출되는 인터페이스 존재

> 위와 같은 핵심 개념 덕분에 "포트와 어댑터 아키텍처"로도 알려져있다.


## 2-6. 정리

- 헥사고날 아키텍처(클린 아키텍처)는 의존성을 역전시킴 
  1. 도메인 코드가 다른 바깥쪽 코드에 의존하지 않기 때문에 영속성과 UI에 특화된 모든 문제로부터 도메인 로직의 결합을 제거 
  2. 코드를 변경할 이유의 수를 줄일 수 있음 
  3. 유지보수성이 좋아짐

또한 도메인 코드는 비즈니스 문제에 딱 맞도록 자유롭게 모델링될 수 있고, 영속성 코드와 UI 코드도 영속성 문제와 UI 문제에 맞게 자유롭게 모델링될 수 있다.

**Reference**

- [만들면서 배우는 클린 아키텍처](http://www.yes24.com/Product/Goods/105138479)
- [마이크로서비스 패턴](http://www.yes24.com/Product/Goods/86542732)
- [클린 아키텍처](http://www.yes24.com/Product/Goods/77283734)