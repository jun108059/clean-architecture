# 5장. 웹 어댑터 구현하기

> 애플리케이션은 대부분 웹 인터페이스 같은 것을 제공한다.  
> ex) 웹 UI, HTTP API ...

**외부 세계와의 모든 커뮤니케이션은 어댑터를 통하는 것이 아키텍처의 목표이다!**

웹 인터페이스를 제공하는 어댑터의 구현 방법을 알아보자

## 1. 의존성 역전

의존성을 `웹 어댑터`와 관련된 **아키텍처 요소**를 중점적으로 표현하면 아래와 같다

<img width="687" alt="image" src="https://user-images.githubusercontent.com/42997924/168854323-1fa4cd8f-389c-4305-8f0c-f9689abc485f.png">

(⬆️ 인커밍 어댑터는 서비스에 의해 구현된 인터페이스인 `전용 포트`를 통해 통신함)

- 웹 어댑터는 '주도하는' 혹은 '인커밍' 어댑터 
  - 외부로부터 요청을 받아 애플리케이션 코어를 호출하고 무슨일을 해야할지 알려준다
  - 이때 제어흐름은 `컨트롤러(어댑터) → 포트 → 서비스(애플리케이션)`

### 1-1. 의존성 역전 원칙 적용

> 위에서 본 것 처럼, 제어 흐름이 왼쪽 → 오른쪽

- 애플리케이션 계층은 웹 어댑터가 통신할 수 있는 특정 포트를 제공함!
- 서비스는 이 `포트를 구현`하고, 웹 어댑터는 이 `포트를 호출`

<img width="445" alt="image" src="https://user-images.githubusercontent.com/42997924/168856355-713a205c-f19b-4041-a921-a7f9bd0aac2a.png">

(⬆️ 포트 인터페이스를 삭제하고 서비스를 직접 호출할 수 있음)

#### 왜 포트를 넣어야할까?

어댑터와 유스케이스는 직접 호출할 수 있는데 왜 간접 계층을 넣어야 할까?

> 애플리케이션 코어가 외부 세계와 **통신할 수 있는 곳에 대한 명세**가 포트이기 때문이다

- 포트를 보면 외부와 어떤 통신이 일어나고 있는지 정확히 알 수 있음
  - ✅ 유지보수하기 편해진다!

> 11장에서 직접 호출하는 지름길에 대해 공부한다..!

### 1-2. 웹에 데이터를 전달할 때

웹소켓을 통해 실시간 데이터를 사용자의 브라우저에 보내는 시나리오를 가정하자

애플리케이션 코어에서실시간 데이터를 웹 어댑터로 보내야만 한다.

<img width="688" alt="image" src="https://user-images.githubusercontent.com/42997924/168859763-1cff8526-3ba9-4880-bd73-e569690e9822.png">

(⬆️ 어댑터는 인커밍 어댑터 + 아웃고잉 어댑터 두가지 역할을 한다)

> 애플리케이션이 웹 어댑터에 능동적으로 알림을 보내야 함  
> 의존성을 올바른 방향으로 유지하기 위해 아웃고잉 포트를 통과해야 함!

- 만약 `포트`가 없다면 `Service`는 `어댑터`를 알게되어 의존성이 발생한다
- 따라서, `포트`는 `어댑터`에 대한 **의존성을 해결**한다

⭐️ 애플리케이션이 웹에 데이터를 전달하는 경우는 다음과 같이 설계하면 **의존성 역전 원칙**을 지킬 수 있다!

위와 같은 `outgoing port`는 웹 어댑터에서 구현하고 애플리케이션 코어에서 호출해야한다.

기존 헥사고날 아키텍처 그림에서 표현하기 어렵게 되어 이해가 어려울 수 있지만, 구현과 호출의 의미로 생각하면 코드로 구현할 수 있다.

## 2. 웹 어댑터의 책임

> 웹 어댑터는 실제로 어떤 일을 할까?

애플리케이션에서 REST API를 제공한다고 가정하면, 웹 어댑터의 책임의 범위는 어떻게 될까?

### 2-1. 웹 어댑터의 일

일반적으로 아래와 같은 일을 한다.

1. HTTP 요청을 자바 객체로 매핑
2. 권한 검사
3. 입력 유효성 검증
4. 입력을 유스케이스의 입력 모델로 매핑
5. 유스케이스 호출
6. 유스케이스의 출력을 HTTP로 매핑
7. HTTP 응답을 반환

<img width="1383" alt="image" src="https://user-images.githubusercontent.com/42997924/169701275-0efd6517-3b3b-4451-a153-72cfe1f97776.png">

위 과정에서 하나라도 문제가 생기면 예외를 던지고, 웹 어댑터는 에러를 호출자에게 보여줄 메시지로 변환한다.

> 책임이 많지만, 이 책임들은 웹 어댑터의 역할이다  
> HTTP와 관련된 것은 애플리케이션 계층에 침투하면 안 된다!

**왜 다 책임져야할까** 
- 애플리케이션 코어가 HTTP를 다루는 것을 알게되면 HTTP를 사용하지 않는 또 다른 인커밍 어댑터의 요청에 대해 동일한 로직을 수행할 수 있는 선택지를 잃게 된다
- 좋은 아키텍처에서는 선택의 여지를 남겨둔다

## 3. 컨트롤러 나누기

**모델을 공유하지 않은 여러 작은 클래스를 만드는 것을 두려워 하지 마라**.

각 컨트롤러가 가능한 좁고, 다른 컨트롤러와 가능한 한 적게 공유하는 웹 어댑터 조각을 구현해야 한다.

- 가독성 떡상
- 테스트 코드를 찾기 쉬움
- 전용 모델 클래스들은 private 선언할 수 있기 때문에 실수로 다른 곳에서 재사용되지 않는다
  - 필요한 필드만 가지고 있는 전용 모델을 만드는 것이 좋다
- 동시작업이 쉽다
- 처음에 공수는 더 많이 들겠지만, 결국 유지보수성이 좋아진다

## 4. 정리

> 유지보수 가능한 소프트웨어를 만드는데 어떻게 도움이 될까?

### 4-1. 웹 어댑터와 애플리케이션 계층의 SRP

애플리케이션의 웹 어댑터의 역할을 다시 간단히 살펴보자.
- HTTP 요청 → 유스케이스에 대한 메서드 호출로 변환 → 결과 반환 → HTTP 변환

웹 어댑터는 어떤 도메인 로직도 수행하지 않는 것을 염두에 둬야 한다.

반면 애플리케이션 계층은 HTTP 관련 작업을 해서는 안된다.

이렇게 하면 필요할 경우 웹 어댑터를 다른 어댑터로 쉽게 교체가 가능하다!

### 4-2. 컨트롤러 세분화하기

웹 컨트롤러를 기능 단위로 세분화하고 전용 모델 클래스를 많이 만드는 것이 유지보수에 도움이 된다.

**Reference**
- [만들면서 배우는 클린 아키텍처 - 자바 코드로 구현하는 클린 웹 애플리케이션](http://www.kyobobook.co.kr/product/detailViewKor.laf?ejkGb=KOR&mallGb=KOR&barcode=9791158392758)